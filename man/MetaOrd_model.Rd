% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/R_R6_class_aaa_init_and_sample.R
\name{MetaOrd_model}
\alias{MetaOrd_model}
\title{MetaOrdDTA Model Class}
\description{
R6 Class for MetaOrdDTA model initialization and sampling.
}
\details{
This class handles:
\itemize{
\item Model initialization and compilation
\item MCMC sampling with NUTS-HMC (using Stan).
\item Parameter updates and diagnostics
}
}
\section{Model Types}{

\itemize{
\item meta_ord: Meta-analysis model for a single ordinal test (e.g., questionnaires). Uses model proposed by Cerullo et al.
Supports missing thresholds in some or all studies.
\item meta_cts: Meta-analysis model for a single continuous test (e.g., biomarkers). Uses the model proposed by Jones et al.
Supports missing thresholds in some or all studies.
\item network_meta_ord: Meta-analysis model for multiple ordinal tests (e.g., questionnaires). Uses the model proposed by Cerullo et al.
and NMA model proposed by Nyaga et al. Supports missing thresholds in some or all studies.
\item network_meta_cts: Meta-analysis model for multiple continuous tests (e.g., biomarkers). Uses the model proposed by Jones et al. and
Nyaga et al. Supports missing thresholds in some or all studies.
}
}

\section{EXAMPLE - Typical workflow}{

\preformatted{
 #### NOTE: Please see the ".R" example files for full details & examples, 
 #### as this is NOT a complete working example, but is provided just to show 
 #### what order you should call things in. 
 ####  -----------  Compile + initialise the model using "MetaOrd_model$new(...)"  ---------------- 
   require(MetaOrdDTA)
   ## NOTE: The "model_args_list" argument is only needed for BUILT-IN (not Stan) models.
   ##
   ## --- INITIALISE MODEL:  --------------------------------------------------------------- 
   ##
   model_obj <- MetaOrdDTA::MetaOrd_model$new(   
                   Model_type = "meta_ord",
                   x = x, ## data
                   model_args_list = model_args_list,
                   n_chains = n_chains
                   init_lists_per_chain = init_lists_per_chain)
   ##
   ## --- SAMPLE MODEL: --------------------------------------------------------------------
   ##
   model_samples <-  model_obj$sample(
                   seed = 123,
                   n_burnin = 500,
                   n_iter = 1000,
                   x = x,
                   n_chains = 16,
                   init_lists_per_chain = init_lists_per_chain,
                   model_args_list = model_args_list)
   ##
   ## --- EXTRACT MODEL RESULTS SUMMARY + DIAGNOSTICS ---------------------------------------  
   ##         
   model_fit <- model_samples$summary(
                   save_log_lik_trace = FALSE, 
                   compute_nested_rhat = FALSE,
                   compute_transformed_parameters = FALSE) #'    
   
   ## extract # divergences + % of sampling iterations which have divergences
   model_fit$get_divergences()
   
   #### --- TRACE PLOTS  ----------------------------------------------------------------------
   ## trace_plots_all <- model_samples$plot_traces() # if want the trace for all parameters 
   trace_plots <- model_fit$plot_traces(
                   params = c("beta", "Omega", "p"), 
                   batch_size = 12)
   
   ## you can extract parameters by doing: "trace$param_name()". 
   ## For example:
   ## display each panel for beta and Omega ("batch_size" controls the # of plots per panel)
   trace_plots$beta[[1]] # 1st (and only) panel
   
   
   #### --- POSTERIOR DENSITY PLOTS -----------------------------------------------------------
   ## density_plots_all <- model_samples$plot_densities() # if want the densities 
   ## for all parameters.
   ## Let's plot the densities for: sensitivity, specificity, and prevalence 
   density_plots <- model_fit$plot_densities(
                     params = c("Se_bin", "Sp_bin", "p"), 
                     batch_size = 12)
   
   ## you can extract parameters by doing: "trace$param_name()". 
   ## For example:
   ## display each panel for beta and Omega ("batch_size" controls the # of plots per panel)
   density_plots$Se[[1]] # Se - 1st (and only) panel
   density_plots$Sp[[1]] # Sp - 1st (and only) panel
   density_plots$p[[1]] # p (prevelance) - 1st (and only) panel
   
   
   ###### --- EXTRACT PARAMETER SUMMARY TIBBLES: ----------------------------------------------
   ## The "model_summary" object (created using the "$summary()" method) contains
   ##  many useful objects. 
   ## For example:
   require(dplyr)
   ## nice summary tibble for main parameters, includes ESS/Rhat, etc:
   model_fit$get_summary_main() %>% print(n = 50) 
   ## nice summary tibble for transformed parameters, includes ESS/Rhat, etc:
   model_fit$get_summary_transformed() %>% print(n = 150) 
   ## nice summary tibble for generated quantities, includes 
   ## ESS/Rhat, etc (for LC-MVP this includes Se/Sp/prevalence):
   model_fit$get_summary_generated_quantities () %>% print(n = 150) 
   
}
}

\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{network}}{Whether to perform meta-analysis (MA) or network-meta-analysis (NMA). The default will depend on the structure of the data (i.e. on \code{x}).}

\item{\code{cts}}{Whether to use continuous model (i.e., Jones et al-based) or ordinal. Default is ordinal. Type of test (and hence the type of model to fit) -
can be either "continuous" (or simply "cts") or "ordinal" (or simply "ord"). The former uses the
model from Jones et al and assumes, that the test is continuous (e.g., biokarkers) and the latter assumes the data is ordinal (e.g., questionnaires).
The latter is generally more flexible so if you are unsure which model type to use, we suggest using "ordinal".
Furthermore, if performing network-meta-analysis (NMA) and you have a mix of continuous and ordinal tests, we also suggest using "ordinal".
The default is "ordinal".}

\item{\code{prior_only}}{Whether to run prior-only (for prior predictive checking) or not. Default is FALSE.}

\item{\code{priors}}{An R list of priors. Default will depend on model.}

\item{\code{init_lists_per_chain}}{A list of dimension n_chains, where each element of the list is another list which contains the #
initial values for the chain. Note that this is the same format for initial values that Stan (both rstan and cmdstanr) uses.}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{network}}{Whether to perform meta-analysis (MA) or network-meta-analysis (NMA). The default will depend on the structure of the data (i.e. on \code{x}).}

\item{\code{cts}}{Whether to use continuous model (i.e., Jones et al-based) or ordinal. Default is ordinal. Type of test (and hence the type of model to fit) -
can be either "continuous" (or simply "cts") or "ordinal" (or simply "ord"). The former uses the
model from Jones et al and assumes, that the test is continuous (e.g., biokarkers) and the latter assumes the data is ordinal (e.g., questionnaires).
The latter is generally more flexible so if you are unsure which model type to use, we suggest using "ordinal".
Furthermore, if performing network-meta-analysis (NMA) and you have a mix of continuous and ordinal tests, we also suggest using "ordinal".
The default is "ordinal".}

\item{\code{prior_only}}{Whether to run prior-only (for prior predictive checking) or not. Default is FALSE.}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-MetaOrd_model-new}{\code{MetaOrd_model$new()}}
\item \href{#method-MetaOrd_model-sample}{\code{MetaOrd_model$sample()}}
\item \href{#method-MetaOrd_model-summary}{\code{MetaOrd_model$summary()}}
\item \href{#method-MetaOrd_model-get_divergences}{\code{MetaOrd_model$get_divergences()}}
\item \href{#method-MetaOrd_model-get_HMC_diagnostic_info}{\code{MetaOrd_model$get_HMC_diagnostic_info()}}
\item \href{#method-MetaOrd_model-get_HMC_info}{\code{MetaOrd_model$get_HMC_info()}}
\item \href{#method-MetaOrd_model-get_summary_main}{\code{MetaOrd_model$get_summary_main()}}
\item \href{#method-MetaOrd_model-get_summary_transformed}{\code{MetaOrd_model$get_summary_transformed()}}
\item \href{#method-MetaOrd_model-get_summary_generated_quantities}{\code{MetaOrd_model$get_summary_generated_quantities()}}
\item \href{#method-MetaOrd_model-get_all_traces_list}{\code{MetaOrd_model$get_all_traces_list()}}
\item \href{#method-MetaOrd_model-get_trace_main}{\code{MetaOrd_model$get_trace_main()}}
\item \href{#method-MetaOrd_model-get_trace_transformed}{\code{MetaOrd_model$get_trace_transformed()}}
\item \href{#method-MetaOrd_model-get_trace_generated_quantities}{\code{MetaOrd_model$get_trace_generated_quantities()}}
\item \href{#method-MetaOrd_model-get_trace_log_lik}{\code{MetaOrd_model$get_trace_log_lik()}}
\item \href{#method-MetaOrd_model-get_traces_as_tibbles}{\code{MetaOrd_model$get_traces_as_tibbles()}}
\item \href{#method-MetaOrd_model-get_efficiency_metrics}{\code{MetaOrd_model$get_efficiency_metrics()}}
\item \href{#method-MetaOrd_model-time_to_target_ESS}{\code{MetaOrd_model$time_to_target_ESS()}}
\item \href{#method-MetaOrd_model-iter_to_target_ESS}{\code{MetaOrd_model$iter_to_target_ESS()}}
\item \href{#method-MetaOrd_model-plot_traces}{\code{MetaOrd_model$plot_traces()}}
\item \href{#method-MetaOrd_model-plot_densities}{\code{MetaOrd_model$plot_densities()}}
\item \href{#method-MetaOrd_model-extract_params}{\code{MetaOrd_model$extract_params()}}
\item \href{#method-MetaOrd_model-run_k_fold_CV}{\code{MetaOrd_model$run_k_fold_CV()}}
\item \href{#method-MetaOrd_model-plot_sROC}{\code{MetaOrd_model$plot_sROC()}}
\item \href{#method-MetaOrd_model-extract_NMA_comparisons}{\code{MetaOrd_model$extract_NMA_comparisons()}}
\item \href{#method-MetaOrd_model-extract_NMA_performance}{\code{MetaOrd_model$extract_NMA_performance()}}
\item \href{#method-MetaOrd_model-extract_AUC}{\code{MetaOrd_model$extract_AUC()}}
\item \href{#method-MetaOrd_model-clone}{\code{MetaOrd_model$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-new"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-new}{}}}
\subsection{Method \code{new()}}{
Create a new "MetaOrd_model" object.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$new(
  debugging = FALSE,
  x = self$x,
  intercept_only = self$intercept_only,
  cov_data = self$cov_data,
  indicator_index_test_in_study = self$indicator_index_test_in_study,
  network = NULL,
  cts = NULL,
  prior_only = NULL,
  model_parameterisation = NULL,
  random_thresholds = NULL,
  Dirichlet_random_effects_type = NULL,
  box_cox = NULL,
  softplus = NULL,
  priors = NULL,
  n_chains = NULL,
  init_lists_per_chain = self$init_lists_per_chain,
  advanced_compile = FALSE,
  force_recompile = FALSE,
  quiet = FALSE,
  compile = TRUE,
  set_custom_CXX_CPP_flags = FALSE,
  CCACHE_PATH = " ",
  custom_cpp_user_header_file_path = NULL,
  CXX_COMPILER_PATH = NULL,
  CPP_COMPILER_PATH = NULL,
  MATH_FLAGS = NULL,
  FMA_FLAGS = NULL,
  AVX_FLAGS = NULL,
  THREAD_FLAGS = NULL,
  custom_file_name = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{The dataset. See class documentation for details.}

\item{\code{intercept_only}}{Optional covariates and baseline cases. See class documentation for details.}

\item{\code{cov_data}}{Optional covariates and baseline cases. See class documentation for details.}

\item{\code{network}}{See class documentation for details.}

\item{\code{cts}}{Whether to use a continuous ("cts") model or whether to use an ordinal ("ord") model.}

\item{\code{prior_only}}{See class documentation for details.}

\item{\code{model_parameterisation}}{See class documentation for details.}

\item{\code{random_thresholds}}{See class documentation for details.}

\item{\code{Dirichlet_random_effects_type}}{See class documentation for details.}

\item{\code{box_cox}}{See class documentation for details.}

\item{\code{softplus}}{See class documentation for details.}

\item{\code{priors}}{See class documentation for details.}

\item{\code{n_chains}}{Number of chains used for burnin. See class documentation for details.}

\item{\code{init_lists_per_chain}}{List of initial values for each chain. See class documentation for details.}

\item{\code{test_type}}{Type of test. See class documentation for details.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Returns self$model_initial_obj, an object generated from the "MetaOrdDTA::prep_data_and_model" function.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-sample"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-sample}{}}}
\subsection{Method \code{sample()}}{
Sample from the model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$sample(
  debugging = self$debugging,
  x = self$x,
  intercept_only = self$intercept_only,
  cov_data = self$cov_data,
  indicator_index_test_in_study = self$indicator_index_test_in_study,
  cts = self$basic_model_options$cts,
  network = self$basic_model_options$network,
  prior_only = self$basic_model_options$prior_only,
  model_parameterisation = self$advanced_model_options$model_parameterisation,
  random_thresholds = self$advanced_model_options$random_thresholds,
  Dirichlet_random_effects_type =
    self$advanced_model_options$Dirichlet_random_effects_type,
  box_cox = self$advanced_model_options$box_cox,
  softplus = self$advanced_model_options$softplus,
  custom_file_name = self$advanced_model_options$custom_file_name,
  priors = self$priors,
  init_lists_per_chain = self$init_lists_per_chain,
  algorithm = "Stan",
  seed = NULL,
  n_superchains = NULL,
  n_chains = self$MCMC_params$n_chains,
  n_burnin = 500,
  n_iter = 1000,
  adapt_delta = 0.8,
  max_treedepth = 10,
  metric_shape = "diag_e",
  cmdstanr_args = list()
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{x}}{The dataset. See class documentation for details.}

\item{\code{init_lists_per_chain}}{List of initial values for each chain. See class documentation for details.}

\item{\code{seed}}{Random MCMC seed.}

\item{\code{n_superchains}}{Number of superchains for nested R-hat (nR-hat; see Margossian et al, 2023) computation.}

\item{\code{n_chains}}{Number of chains used for sampling (i.e., post-burnin). Note that this must match the length of "init_lists_per_chain".}

\item{\code{n_burnin}}{The number of burnin iterations. Default is 500.}

\item{\code{n_iter}}{The number of sampling (i.e., post-burnin) iterations. Default is 1000.}

\item{\code{adapt_delta}}{The Metropolis-Hastings target acceptance rate. Default is 0.80. If there are divergences, sometimes increasing this can help, at the cost
of efficiency (since this will decrease the step-size (epsilon) and increase the number of leapfrog steps (L) per iteration).}

\item{\code{max_treedepth}}{Proportional to the maximum number of leapfrog steps. The default is 10.}

\item{\code{metric_shape}}{The shape of the metric to use for the main parameters, which is adapted during the burnin period. Can be either \code{"diag"} or
\code{"dense"}. The default is \code{"diag"} (i.e. a diagonal metric).}

\item{\code{model_args_list}}{List of model arguments. See class documentation for details.}

\item{\code{stan_data_list}}{List of Stan data (optional). See class documentation for details.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Returns self invisibly, allowing for method chaining of this classes (MetaOrd_model) methods. E.g.: model$sample(...)$summary(...).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-summary"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-summary}{}}}
\subsection{Method \code{summary()}}{
Create and compute summary statistics, traces and model diagnostics.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$summary(
  debugging = self$debugging,
  compute_main_params = TRUE,
  compute_transformed_parameters = TRUE,
  compute_generated_quantities = TRUE,
  save_log_lik_trace = TRUE,
  compute_nested_rhat = NULL,
  n_superchains = NULL,
  save_trace_tibbles = FALSE,
  use_BayesMVP_for_faster_summaries = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{compute_main_params}}{Whether to compute the main parameter summaries. Default is TRUE.}

\item{\code{compute_transformed_parameters}}{Whether to compute transformed parameter summaries. Default is TRUE. For Stan models, this will be for
all of the parameters defined in the "transformed parameters" block, EXCEPT for the (transformed) nuisance parameters and log_lik (see "save_log_lik_trace"
for more information on log_lik).}

\item{\code{compute_generated_quantities}}{Whether to compute the summaries for generated quantities. Default is TRUE.}

\item{\code{save_log_lik_trace}}{Whether to save the log-likelihood (log_lik) trace. Default is FALSE. For Stan models, this will only work
if there is a "log_lik" parameter defined in the "transformed parameters" model block.}

\item{\code{compute_nested_rhat}}{Whether to compute the nested rhat diagnostic (nR-hat) (Margossian et al, 2023). This is useful when
running many (usually short) chains. Also see "n_superchains" argument.}

\item{\code{n_superchains}}{The number of superchains to use for the computation of nR-hat.
Only relevant if \code{compute_nested_rhat = TRUE}.}

\item{\code{save_trace_tibbles}}{Whether to save the trace as tibble dataframes as well as 3D arrays. Default is FALSE.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Returns a new MetaOrd_plot_and_diagnose object (from the "MetaOrd_plot_and_diagnose" R6 class) for creating MCMC diagnostics and plots.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_divergences"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_divergences}{}}}
\subsection{Method \code{get_divergences()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_divergences()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns self$internal_obj$summaries$divergences obtained from the main "MetaOrd_model" R6 class.
self$internal_obj$summaries$divergences contains divergence information (e.g. \% of transitions which diverged).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_HMC_diagnostic_info"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_HMC_diagnostic_info}{}}}
\subsection{Method \code{get_HMC_diagnostic_info()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_HMC_diagnostic_info()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns self$internal_obj$summaries$divergences obtained from the main "MetaOrd_model" R6 class.
self$internal_obj$summaries$divergences contains divergence information (e.g. \% of transitions which diverged).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_HMC_info"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_HMC_info}{}}}
\subsection{Method \code{get_HMC_info()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_HMC_info()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns a list containing HMC algorithm info (including timings and some efficiency metrics)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_summary_main"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_summary_main}{}}}
\subsection{Method \code{get_summary_main()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_summary_main()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns main parameter summaries as a tibble.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_summary_transformed"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_summary_transformed}{}}}
\subsection{Method \code{get_summary_transformed()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_summary_transformed()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns transformed parameter summaries as a tibble.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_summary_generated_quantities"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_summary_generated_quantities}{}}}
\subsection{Method \code{get_summary_generated_quantities()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_summary_generated_quantities()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns generated quantities as a tibble.
Convenience method for ALL traces
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_all_traces_list"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_all_traces_list}{}}}
\subsection{Method \code{get_all_traces_list()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_all_traces_list()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns all traces including as tibbles (if enabled) and as 3D array's (iterations, chains, parameters).
Convenience method for log_lik trace
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_trace_main"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_trace_main}{}}}
\subsection{Method \code{get_trace_main()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_trace_main()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns  log_lik trace as 3D array (iterations, chains, parameters).
Convenience method for log_lik trace
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_trace_transformed"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_trace_transformed}{}}}
\subsection{Method \code{get_trace_transformed()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_trace_transformed()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns  log_lik trace as 3D array (iterations, chains, parameters).
Convenience method for log_lik trace
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_trace_generated_quantities"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_trace_generated_quantities}{}}}
\subsection{Method \code{get_trace_generated_quantities()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_trace_generated_quantities()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns  log_lik trace as 3D array (iterations, chains, parameters).
Convenience method for log_lik trace
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_trace_log_lik"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_trace_log_lik}{}}}
\subsection{Method \code{get_trace_log_lik()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_trace_log_lik()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns  log_lik trace as 3D array (iterations, chains, parameters).
Convenience method for posterior draws (as tibbles)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_traces_as_tibbles"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_traces_as_tibbles}{}}}
\subsection{Method \code{get_traces_as_tibbles()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_traces_as_tibbles()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns trace as tibbles. The trace gets returned as 3 seperate tibbles (one tibble for the
main parameters, one for the transformed parameters, and one for generated quantities).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-get_efficiency_metrics"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-get_efficiency_metrics}{}}}
\subsection{Method \code{get_efficiency_metrics()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$get_efficiency_metrics()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Returns a list containing efficiency metrics including:
\itemize{
\item time_burnin: Time spent in burnin phase
\item time_sampling: Time spent sampling
\item time_total_MCMC: Total time spent doing MCMC/HMC sampling, excluding time to compute summaries and diagnostics.
\item time_total_inc_summaries: Total time spent doing MCMC/HMC sampling, including time to compute summaries and diagnostics.
\item Min_ESS_main: The minimum ESS of the main model parameters.
\item Min_ESS_per_sec_sampling: The minimum ESS per second for the sampling phase.
\item Min_ESS_per_sec_total: The minimum ESS per second for the total model run time, including any time spent computing
summaries and diagnostics.
\item Min_ESS_per_grad_sampling:  The minimum ESS per gradient evaluation for the sampling phase.
\item grad_evals_per_sec: The number of gradient evaluations performed per second.
\item est_time_to_100_ESS_sampling: The estimated sampling time to reach a minimum ESS of 100.
\item est_time_to_1000_ESS_sampling: The estimated sampling time to reach a minimum ESS of 1000.
\item est_time_to_10000_ESS_sampling: The estimated sampling time to reach a minimum ESS of 10,000.
\item est_time_to_100_ESS_wo_summaries: The estimated total time (expluding time to compute model summaries and diagnostics)
to reach a minimum ESS of 100.
\item est_time_to_1000_ESS_wo_summaries: The estimated total time (expluding time to compute model summaries and diagnostics)
to reach a minimum ESS of 1000.
\item est_time_to_10000_ESS_wo_summaries: The estimated total time (expluding time to compute model summaries and diagnostics)
to reach a minimum ESS of 10,000.
\item est_time_to_100_ESS_inc_summaries: The estimated total time (including time spent computing model summaries and
diagnostics) to reach a minimum ESS of 100.
\item est_time_to_1000_ESS_inc_summaries: The estimated total time (including time spent computing model summaries and
diagnostics) to reach a minimum ESS of 1000.
\item est_time_to_10000_ESS_inc_summaries: The estimated total time (including time spent computing model summaries and
diagnostics) to reach a minimum ESS of 10,000.
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-time_to_target_ESS"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-time_to_target_ESS}{}}}
\subsection{Method \code{time_to_target_ESS()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$time_to_target_ESS(target_ESS)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{target_ESS}}{The target ESS.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Returns a list called "target_ESS_times" which contains the estimated sampling time to reach the target ESS
("sampling_time_to_target_ESS"), the estimated total time excluding the time it takes to compute model summaries
("total_time_to_target_ESS_wo_summaries"), and the total estimated time to reach the
target ESS ("total_time_to_target_ESS_with_summaries").
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-iter_to_target_ESS"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-iter_to_target_ESS}{}}}
\subsection{Method \code{iter_to_target_ESS()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$iter_to_target_ESS(target_ESS)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{target_ESS}}{The target ESS.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Returns a list called "target_ESS_iter" which contains the estimated number of sampling iterations (n_iter) to
reach the target ESS ("sampling_iter_to_target_ESS").
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-plot_traces"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-plot_traces}{}}}
\subsection{Method \code{plot_traces()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$plot_traces(
  debugging = FALSE,
  param_string = NULL,
  condition = "exact_match",
  batch_size = 9
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{debugging}}{Whether debugging mode is turned on (\code{TRUE}) or off (\code{FALSE}). The default is FALSE.}

\item{\code{param_string}}{The parameters to generate trace plots for. This is a character vector - e.g. to plot trace plots for
beta: param_string = c("beta").
The default is NULL and the trace plots for all model parameters (which have a trace array) will be plotted.}

\item{\code{batch_size}}{The number of trace plots to display per panel. Default is 9.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
If no parameters specified (i.e. param_string = NULL), then this will return an object containing the trace plots for all
model parameters  which have a trace array.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-plot_densities"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-plot_densities}{}}}
\subsection{Method \code{plot_densities()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$plot_densities(
  debugging = FALSE,
  param_string = NULL,
  condition = "exact_match",
  batch_size = 9
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{debugging}}{Whether debugging mode is turned on (\code{TRUE}) or off (\code{FALSE}). The default is FALSE.}

\item{\code{param_string}}{The parameters to generate posterior density plots for. This is a character vector - e.g. to plot the
posterior density plots for beta: param_string = c("beta").
The default is NULL and the posterior density plots for all model parameters (which have a trace array) will be plotted.}

\item{\code{batch_size}}{The number of posterior density plots to display per panel. Default is 9.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
If no parameters specified (i.e. param_string = NULL), then this will return an object containing the posterior density
plots for all model parameters which have a trace array.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-extract_params"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-extract_params}{}}}
\subsection{Method \code{extract_params()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$extract_params(
  debugging = FALSE,
  params,
  tibble = NULL,
  condition = "exact_match",
  combine = TRUE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{debugging}}{...}

\item{\code{params}}{...}

\item{\code{tibble}}{...}

\item{\code{condition}}{...}

\item{\code{combine}}{...}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Extract params
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-run_k_fold_CV"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-run_k_fold_CV}{}}}
\subsection{Method \code{run_k_fold_CV()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$run_k_fold_CV(
  debugging = FALSE,
  K = 10,
  n_burnin = self$MCMC_params$n_burnin,
  n_iter = self$MCMC_params$n_iter,
  n_chains = self$MCMC_params$n_chains,
  adapt_delta = self$MCMC_params$adapt_delta,
  max_treedepth = self$MCMC_params$max_treedepth,
  parallel = "auto",
  n_workers = NULL,
  output_dir = "cv_results",
  use_BayesMVP_for_faster_summaries = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{debugging}}{...}

\item{\code{params}}{...}

\item{\code{tibble}}{...}

\item{\code{condition}}{...}

\item{\code{combine}}{...}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Extract params
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-plot_sROC"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-plot_sROC}{}}}
\subsection{Method \code{plot_sROC()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$plot_sROC(
  new_cov_data = NULL,
  debugging = FALSE,
  df_true = NULL,
  conf_region_colour = "blue",
  pred_region_colour = "blue",
  test_names = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{df_true}}{...}

\item{\code{conf_region_colour}}{...}

\item{\code{pred_region_colour}}{...}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
sROC plot(s).
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-extract_NMA_comparisons"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-extract_NMA_comparisons}{}}}
\subsection{Method \code{extract_NMA_comparisons()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$extract_NMA_comparisons(
  new_cov_data = NULL,
  debugging = FALSE,
  test_names = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{debugging}}{...}

\item{\code{test_names}}{...}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NMA comparisons summary
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-extract_NMA_performance"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-extract_NMA_performance}{}}}
\subsection{Method \code{extract_NMA_performance()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$extract_NMA_performance(
  new_cov_data = NULL,
  debugging = FALSE,
  test_names = NULL
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{debugging}}{...}

\item{\code{test_names}}{...}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NMA performance metrics (e.g., DOR) summary
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-extract_AUC"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-extract_AUC}{}}}
\subsection{Method \code{extract_AUC()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$extract_AUC(
  new_cov_data = NULL,
  debugging = FALSE,
  test_names = NULL,
  use_BayesMVP_for_faster_summaries = NULL,
  compute_nested_rhat = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{debugging}}{...}

\item{\code{test_names}}{...}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NMA AUC summary
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-MetaOrd_model-clone"></a>}}
\if{latex}{\out{\hypertarget{method-MetaOrd_model-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{MetaOrd_model$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
